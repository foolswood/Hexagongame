<html>
<head>
    <title>Chromagon - Multiplayer</title>
    <link rel="icon" type="image/x-icon" href="favicon.svg"/>
    <link rel="stylesheet" type="text/css" href="hexagons.css">
    <link rel="stylesheet" type="text/css" href="multiplayer.css">
</head>
<body>
<div id="turnTimer" class="bg"></div>
<object id="A" type="image/svg+xml" data="hexagons.svg" width="100%" height="100%"></object>
<div id="turnIndicator" class="hide">
    <svg class="centered" height="50%" width="50%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg">
       <polygon id="octagon" points="27,1 73,1 99,27 99,73 73,99 27,99 1,74 1,27" stroke="white" opacity="0.3">
            <animate attributeName="fill" from="#FFFF" to="#FFF0" fill="freeze"/>
       </polygon>
    </svg>
</div>
<object id="won" class="hide" type="image/svg+xml" data="star.svg"></object>
<object id="lost" class="hide" type="image/svg+xml" data="spoon.svg"></object>
<a href="instructions.html#multiplayer" target="_blank"/>
    <img id="q" src="qmark.svg"/>
</a>
</body>

<script src="svg_interface.es" type="text/ecmascript"></script>
<script src="serialiser.es" type="text/ecmascript"></script>
<script src="shard_common.es" type="text/ecmascript"></script>
<script src="solver.es" type="text/ecmascript"></script>

<script>
const server = 'ws://svr.foolswood.co.uk:9783/mph'  // Change this when developing locally
const turnTime = 30

const arrayRemove = function(arr, item) {
    for (var idx = 0; idx < arr.length; idx++) {
        if (arr[idx] === item) {
            arr.splice(idx, 1)
            return
        }
    }
}

const getTurnLabeller = function() {
    const turnIndicator = document.getElementById('turnIndicator')
    const octagon = document.getElementById('octagon')
    const octagonAnim = octagon.children[0]
    const turnIndicatorCallback = new Pressable(turnIndicator)
    const octagonCallback = new Pressable(octagon)
    const turnTimer = document.getElementById('turnTimer')
    const resetTimer = function() {
        turnTimer.setAttribute('style', 'background: #EEE; height: 0%;')
    }
    return function(nPlayers, ownId) {
        var timeoutCb
        var players = []
        for (var i = 0; i < nPlayers; i++)
            players.push(i)
        var turnIdx = 0
        var currentPlayer = ownId
        const turnChanged = function() {
            if (currentPlayer == ownId) {
                octagonAnim.setAttribute('dur', (turnTime * (players.length - 1)).toString() + 's')
                octagonAnim.beginElement()
            }
            currentPlayer = players[turnIdx]
            if (players.indexOf(ownId) === -1 || players.length === 1) {
                resetTimer()
                turnIndicator.setAttribute('class', 'hide')
            } else if (currentPlayer === ownId) {
                turnIndicator.setAttribute('class', 'hide')
                turnTimer.style.transition = 'all ' + turnTime.toString() + 's ease-in'
                turnTimer.style.background = '#222'
                turnTimer.style.height = '100%'
            } else {
                resetTimer()
                turnIndicator.setAttribute('class', '')
            }
        }
        turnChanged()
        this.advance = function() {
            turnIdx++;
            if (turnIdx === players.length)
                turnIdx = 0
            turnChanged()
        }
        this.cleanUp = function() {
            turnIndicator.setAttribute('class', 'hide')
            resetTimer()
            turnTimer.removeEventListener('transitionend', timeoutCb)
        }
        this.eliminate = function(player) {
            arrayRemove(players, player)
            if (turnIdx === players.length)
                turnIdx = 0
            turnChanged()
        }
        this.__defineGetter__('ownId', () => ownId)
        this.__defineGetter__('players', () => players)
        this.__defineGetter__('currentPlayer', () => currentPlayer)
        this.__defineSetter__('callback', function(f) {
            turnIndicatorCallback.set(f)
            octagonCallback.set(f)
        })
        this.__defineSetter__('turnTimeoutCb', function(cb) {
            timeoutCb = cb
            turnTimer.addEventListener('transitionend', cb)
        })
    }
}

const multiplayerGame = function(iface, ws, tl, maze, gameId) {
    const sendMsg = function(type, extra) {
        extra['type'] = type
        extra['game_id'] = gameId
        ws.send(JSON.stringify(extra))
    }
    const sm = new shardMoves(iface, maze)
    var outcomeElem
    const cleanUp = function() {
        sm.cleanUp()
        tl.cleanUp()
        if (outcomeElem !== undefined)
            outcomeElem.setAttribute("class", "hide")
    }
    this.cleanUp = cleanUp
    const gameOver = function() {
        sendMsg('over', {})
    }
    const win = function(player, waitSecs) {
        tl.cleanUp()
        if (player === tl.ownId)
            outcomeElem = document.getElementById("won")
        else
            outcomeElem = document.getElementById("lost")
        outcomeElem.setAttribute("class", "centered prize")
        setTimeout(gameOver, 1000 * waitSecs)
    }
    var shardHexMoves = {}
    const checkWin = function() {
        if (sm.finished()) {
            sm.showWin(gameOver)
            win(tl.currentPlayer, 4)
        } else
            tl.advance()
    }
    const getMoveFunc = function(hex) {
        const pos = hex.position
        const shardMoveFunc = sm.getHexFunc(hex)
        shardHexMoves[pos.toString()] = shardMoveFunc
        const moveFunc = function() { // hex click cb
            const c = shardMoveFunc()
            if (c !== null) {
                sendMsg('move', {pos: pos})
                checkWin()
            }
        }
        return moveFunc
    }
    sm.hexFuncsSetup(getMoveFunc)
    this.move = function(pos) {  // move from network
        if (shardHexMoves[pos.toString()]() !== null) {
            checkWin()
        }
    }
    const eliminate = function(player) {
        if (player === tl.ownId) {
            outcomeElem = document.getElementById("lost")
            outcomeElem.setAttribute("class", "centered prize")
        }
        tl.eliminate(player)
        if (tl.players.length === 1) {
            win(tl.currentPlayer, 6)
            return
        }
    }
    this.leave = function(player) {
        eliminate(player)
    }
    const impossibleGuessed = function(guessingPlayer, state) {
        // Run solver to determine if a win condition exists
        var solutions = solver(state, get_shard_moves_func(iface), undefined)
        for (let s in solutions) {
            if (is_win_state(JSON.parse(s), undefined)) {
                // Show the solution briefly (if it was our guess)
                eliminate(guessingPlayer)
                if (guessingPlayer === tl.ownId)
                    showSolution(iface, solutions[s][0])
                return
            }
        }
        // No valid solutions, so a correct guess
        win(guessingPlayer, 8)
    }
    this.impossible = impossibleGuessed
    const impossiblePressed = function() {
        const state = sm.state()
        sendMsg('impossible', {state: state})
        impossibleGuessed(tl.ownId, state)
    }
    sm.setMarkerCb(impossiblePressed)
    tl.callback = impossiblePressed
    tl.turnTimeoutCb = function () {
        sendMsg('timeout', {})
        eliminate(tl.ownId)
    }
}

const serverConnector = function(iface) {
    var ws
    const turnLabeller = getTurnLabeller()
    var game
    const startScreen = function() {
        if (game !== undefined) {
            game.cleanUp()
            game = undefined
        }
        iface.clear()
        iface.addHex([0,0], 'b')
        iface.addHex([2,0], 'g')
        iface.addHex([1,1], 'r')
        iface.maximise()
    }
    const handleMsg = function(e) {
        const m = JSON.parse(e.data)
        switch (m.type) {
            case 'lobby':
                startScreen()
                showSpinner()
                break
            case 'start':
                if (game !== undefined)
                    game.cleanUp()
                game = new multiplayerGame(
                    iface, ws, new turnLabeller(m.players, m.own_id), m, m.game_id)
                break
            case 'left':
                game.leave(m.player)
                break
            case 'move':
                game.move(m.pos)
                break
            case 'impossible':
                game.impossible(m.player, m.state)
                break
        }
    }
    const showSpinner = function() {
        iface.addRoute([[[1, 1], 'g'], [[0, 0], 'r'], [[2, 0], 'b'], [[1, 1], 'g']])
    }
    startScreen()
    ws = new WebSocket(server)
    ws.addEventListener('message', handleMsg)
    // When you get here it'd be good to do something with the error and give a reconnect option
    ws.addEventListener('error', startScreen)
    ws.addEventListener('close', startScreen)
}

window.onload = () => serverConnector(new SVGInterface("A"))
</script>
</html>
